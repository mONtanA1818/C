# C排序算法

## 1.冒泡排序

### 定义:

就像碳水饮料里的气泡一样,一点往上浮动, 所以叫冒泡排序

````
[]表示排好序 {}表示比较后交换的结果

第一轮开始： 4 2 9 1 从第一个数开始，4 比 2 大，交换 4，2
第一轮： {2 4} 9 1  接着 4 比 9 小，不交换
第一轮： 2 {4 9} 1  接着 9 比 1 大，交换 9，1
第一轮： 2 4 {1 9}  已经到底，结束
第一轮结果： 2 4 1 [9] 

第二轮开始：2 4 1 [9] 从第一个数开始，2 比 4 小，不交换
第二轮： {2 4} 1 [9] 接着 4 比 1 大，交换 4，1
第二轮： 2 {1 4} [9] 已经到底，结束
第二轮结果： 2 1 [4 9] 

第三轮开始：2 1 [4 9] 从第一个数开始，2 比 1 大，交换 2，1
第三轮： (1 2} [4 9] 已经到底，结束
第三轮结果： 1 [2 4 9] 

结果： [1 2 4 9]
````

### 代码实现

````c
void bubble(int *a, int n){
    for (int i = n-1; i > 0; --i)
    {
        // 每次从第一位开始比较，比较到第 i 位就不比较了，因为前一轮该位已经排好了
        for (int j = 0; j < i; ++j)
        {
            if (a[j]>a[j+1])
            {
                int temp =a[j];
                a[j]=a[j+1];
                a[j+1]=temp;
            }
        }
    }
}
````

### 复杂度O(N^2^)

第一次比较次数 N-1

第二次比较次数 N-2

第三次比较次数 N-3

...

...

第N次比较次数 1

比较次数：1 + 2 + 3 + ... + (N-1) = (N^2^ - N)/2，是一个平方级别的时间复杂度，我们可以记为：O(N^2^)。

---

## 选择排序

### 定义:

像打扑克排一样, 每次从左往右看, 将最小的放在最左边, 即每次从左往右扫描, 找到第`i`小的数,然后把它放在第`i-1`位

```
[]表示排好序

起始： 4 2 9 1  未排序数列从左扫描最小的数是 1，与第一个元素 4 交换，交换 1，4
一轮： [1] 2 9 4 未排序数列从左扫描最小的数是 2，不需要交换
二轮： [1 2] 9 4 未排序数列从左扫描最小的数是 4，与第三个元素 9 交换，交换 4，9
三轮： [1 2 4] 9 未排序数列只有 1 个数，结束
结果： [1 2 4 9]
```

### 代码实现:

````c
#include <stdio.h>
void printarr(int *a,int len);
void SelectSort(int *arr, int len);
int main(void){
    int list[4]={2,9,4,1};

    printarr(list,4);
    SelectSort(list,4);
}

void SelectSort(int *arr, int len)
{
    int min;
    int minid=0;
    for (int i = 0; i < len-1; i++)
    {
        for (int j = i; j < len; j++)
        {
            if (arr[minid]>arr[j])
            {
                minid=j;
            }
        }
        if (minid!=i)
        {
            int temp=arr[i];
            arr[i]=arr[minid];
            arr[minid]=temp;
        }
    }
}

void printarr(int *a,int len){
    for (int i = 0; i < len; i++)
    {
        printf("%d ",a[i]);
    }
}
````

### 复杂度:O(N^2^):

比较的次数和冒泡排序一样多,因为扫描过程也是比较的过程，只不过交换的次数减少为每轮`1`次。最佳和最坏时间复杂度仍然是*O(n^2^)*。
